

###########################################################
# Construct a dictionary, denoted by `A`, which satisfies 
# the property that `A[k,i,m] = 1` if the k-th ranking
# in Σ most prefers product i among all products in
# the assortment past_assortments[k]. Otherwise, 
# we have `A[k,i,m] = 0`.
###########################################################

function Construct_A(past_assortments, Σ)

    # Compute the number of past assortments
    M = length(past_assortments)

    # Compute the number of distinct rankings
    K = length(Σ)

    # Initialize the data structure `A`
    A = Dict()
    for k=1:K, m=1:M, i=past_assortments[m]
        A[k,i,m] = 0
    end

    # Populate the data structure `A`
    for k=1:K, m=1:M
        
        # Compute the most preferred product in the assortment
        # under ranking Σ[k]
        best_i = 0
        for i in past_assortments[m]
            if Σ[k][i] <= Σ[k][best_i]
                best_i = i
            end
        end

        # Update the corresponding value of A
        A[k,best_i,m] = 1
    end

    # Return the data structure A
    return A
end


###########################################################
# Compute the historical sales data v for a collection of
# past assortments, set of rankings Σ, and a probability
# distribution over the rankings λ
###########################################################

function GetFrequencies(λ,past_assortments,Σ)
    
    # Get the number of past assortments
    M = length(past_assortments)

    # Get the number of rankings
    K = length(Σ)

    # Get the data structure `A`
    A = Construct_A(past_assortments, Σ)   

    # Compute the historical sales data, `v`
    v = Dict()
    for m=1:M
        v[m] = Dict()
        for i ∈ past_assortments[m]
            v[m][i] = sum(A[k,i,m]*λ[k] for k=1:K)
        end
    end

    # Return the historical sales data
    return v
end


###########################################################
# Estimate the ranking-based choice model from the 
# historical sales data v for a collection of past
# assortments.
###########################################################

function EstimateDistribution(past_assortments,v,Σ,gurobi_env)
 
    # Get the number of past assortments
    M = length(past_assortments)

    # Get the number of rankings
    K = length(Σ)

    # Get the data structure `A`
    A = Construct_A(past_assortments, Σ)   
   
    # Compute a random objective vector 
    cost_vec = rand(K)

    # Initialize the linear optimization problem for estimating
    # the ranking-based choice model
    model = Model(with_optimizer(Gurobi.Optimizer,gurobi_env))
    set_silent(model)
    
    # Decision variables
    @variable(model, λ[1:K] ≥ 0)

    # Primary constraints
    @constraint(model, sum(λ[k] for k=1:K) == 1)
    @constraint(model, Consistency[m=1:M,i=past_assortments[m]], sum(A[k,i,m]*λ[k] for k=1:K) == v[m][i])

    # Objective
    @objective(model, Min, sum(λ[k]*cost_vec[k] for k=1:K))

    # Solve the optimization problem
    optimize!(model)

    # Return the optimal solution
    return value.(λ)
end


###########################################################
# Compute the best assortment under a given ranking-based
# choice model.
###########################################################

function GetOptimalAssortment(λ,n,r,Σ,gurobi_env)
    K = length(Σ)
    model = Model(with_optimizer(Gurobi.Optimizer,gurobi_env))
    set_silent(model)
    @variable(model, x[1:n], Bin)
    @variable(model, y[k=1:K,i=0:n] ≥ 0)
    @objective(model, Max, sum(r[i]*λ[k]*y[k,i] for i=0:n,k=1:K))
    @constraint(model, EqualOne[k=1:K], sum(y[k,i] for i=0:n) == 1)
    @constraint(model, Upper[k=1:K,i=1:n], y[k,i] ≤ x[i])
    @constraint(model, Bound1[k=1:K, i=1:n], sum(y[k,j] for j in 0:n if Σ[k][j] > Σ[k][i]) ≤ 1 - x[i])
    @constraint(model, Bound2[k=1:K], sum(y[k,j] for j in 0:n if Σ[k][j] > Σ[k][0]) == 0)
    optimize!(model)
    x_out = value.(x)
    assortment = Set([0])
    for i=1:n
        if x_out[i] >= 0.99
            push!(assortment, i)
        end
    end
    return assortment, objective_value(model)
end


###########################################################
# Get the best-case or worst-case expected revenue 
# associated with an assortment S, when the historical
# sales data v is generated by the past_assortments.
###########################################################

function EvaluateAssortment(S_new,r,past_assortments,v,n,Σ,gurobi_env,best_case=true)
 
    # Get the number of past assortments
    M = length(past_assortments)

    # Get the number of rankings
    K = length(Σ)

    # Get the data structure `A`
    A = Construct_A(past_assortments, Σ)   
   
    # Initialize the model
    model = Model(with_optimizer(Gurobi.Optimizer,gurobi_env))
    set_silent(model)

    # Get the revenue for the new assortment under each preference list
    Rev_new = Dict()
    A_new = Construct_A([S_new], Σ)
    for k=1:K
        Rev_new[k] = sum(A_new[k,i,1]*r[i] for i=S_new)
    end

    # Decision variables
    @variable(model, λ[1:K] ≥ 0)

    # Primary constraints
    @constraint(model, sum(λ[k] for k=1:K) == 1)
    @constraint(model, Consistency[m=1:M,i=past_assortments[m]], sum(A[k,i,m]*λ[k] for k=1:K) == v[m][i])

    # Objective
    if best_case
        @objective(model, Max, sum(Rev_new[k]*λ[k] for k=1:K))
    else
        @objective(model, Min, sum(Rev_new[k]*λ[k] for k=1:K))
    end

    # Solve
    optimize!(model)
    return objective_value(model)
end


###########################################################
# Generate a ranking-based choice model with sparsity
# (Note: this algorithm is efficient only if sparse ≪ n!)
###########################################################

function GetRandomDistribution(n,sparse=100)

    # Generate a probability distribution by sampling uniformly over the probability simplex
    U = -1*log.(rand(sparse))
    U_sum = sum(U)
    λ_true = U ./ U_sum

    # Generate a random selection of permutations
    existing_permutations = Set()
    Σ = []
    for k=1:sparse
     
        # Do rejection sampling to generate a permutation
        while true
            # Generate a rnadom permutation
            random_permutation = randperm(n+1) .- 1
    
            # Check if random_permutation has already been generated
            if random_permutation ∉ existing_permutations
    
                # Add the new permutation
                push!(existing_permutations, random_permutation)
                push!(Σ, Dict( i => random_permutation[i+1] for i=0:n))
                break
            end
        end
    end

    return Σ, λ_true
end

